# Самигуллин Равиль гр 6133
Я решил реализовать данный проект на питоне, что бы сравнить совой вариант с использованной мной библиотекой CV2.

Программа на CPU работала стабильно, и время работы зависило в основном от размера окна пиксилей, что впринципе логично.

Функция библиотеки CV2 давала неплохой результат при этом работая в 270 раз быстрее, но результаты все же отличаются довольно сильно.

Функция параллели на питоне может быть реализована десятком методов, я выбрал основные numpy, cupy, numba, и попытался реализовать
параллель результаты хуже некуда,
cupy работало даже медленнее чем на cpu я прождал два часа, и понял что это уже слишком
numpy тоже самое что и cupy, работает больше двух часов результата даже с окном в 9 пикселей нет,

![Текст с описанием картинки](Bilateral_Filtering/image/cpu.png)

<image src="/image/dwsample-bmp-1920.bmp" alt="Исходное изображение">

cuda, это библиотека обладает несколькими модулями для распараллеливания, я использовал @vectorize, @cuda
при этом там так же можно использовать разделение по блокам и нитям как в c++, вот что я сделал

    ```threads_per_block = (16, 16)
    blocks_per_grid_x = (width + threads_per_block[0] - 1) // threads_per_block[0]
    blocks_per_grid_y = (height + threads_per_block[1] - 1) // threads_per_block[1]
    blocks_per_grid = (blocks_per_grid_x, blocks_per_grid_y)```
    
Здесь впринципе видно как было проведено разделение, но проблема заключалась в том что блок numba работает с формулами
содержащими мат операции cupy, numpy, то есть я в ручную разделил блоки и нити и применил к cupy и numpy, но ничего не вышло,
из-за несовместимости версий, numpy, cupy последней версии отказывались работать с numba, я решил понизить версии и попробовать снова 
используя pip install numpy==1.23 но и это не помогло и все так же получал одно и тоже сообщение об ошибке, в конечном итоге
ничего не вышло используя эти функции библиотек.
Так же я предпологал провести разделение по окну, но не успел, хотя это в любом случае не заработало бы(.

В итоге пришлось перейти на pytorch, и попробовать там распараллелить.



В следующий раз постараюсь сделать на c++, там как то корректнее это работает.
