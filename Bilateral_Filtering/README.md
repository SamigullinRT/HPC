# Самигуллин Равиль гр 6133
Я решил реализовать данный проект на питоне.

Перебрал все способы и самым нормаьным вариантом оказалась Pycuda.

# numpy, cupy

Функция параллели на питоне может быть реализована десятком методов, я выбрал основные numpy, cupy, numba, и попытался реализовать
параллель результаты хуже некуда, cupy работало даже медленнее чем на cpu я прождал два часа, и понял что это уже слишком
numpy тоже самое что и cupy, работает больше двух часов результата даже с окном в 3x3 пикселей.

<image src="image/dwsample-bmp-1920.bmp" alt="Исходное изображение" title="Исходное изображение" width="400"/><image src="image/gpu.png" alt="После кода на GPU" title="После кода на GPU" width="400"/>

# CV2

<image src="image/dwsample-bmp-1920.bmp" alt="Исходное изображение"  width="400"/> <image src="image/image_cv2 (2).bmp" alt="После кода на CV2 изображение"  width="400"/>

# CUDA (библиотека питон)

Использовал библиотеку Cuda, это библиотека обладает несколькими модулями для распараллеливания, я использовал @vectorize, @cuda, но проблема заключалась в том
что блок numba работает с формулами содержащими мат операции cupy, numpy, то есть я в ручную разделил блоки и нити и применил к cupy и numpy, но ничего не вышло,
из-за несовместимости версий, numpy, cupy последней версии отказывались работать с numba, я решил понизить версии и попробовать снова 
используя `pip install numpy==1.23` но и это не помогло и все так же получал одно и тоже сообщение об ошибке, в конечном итоге
ничего не вышло используя эти функции библиотек.

# Pycuda (единственный рабочий вариант)

В итоге пришлось перейти на pycuda, которая сработала отлично:

Реализация параллели:

Циклы обработки пикселей: Циклы, отвечающие за обход каждого пикселя изображения, выполнены параллельно. Каждый поток сопоставляется с определенным пикселем с помощью переменных `threadIdx.x, blockDim.x, blockIdx.x` и аналогичных переменных для оси y. Это позволяет каждому потоку обрабатывать отдельный набор пикселей независимо от других потоков.

Вычисление весовых коэффициентов: Часть кода, отвечающая за вычисление весовых коэффициентов `g` и `r`, также распараллелена. Каждый поток вычисляет `g` и `r` для своего соответствующего пикселя.

Накопление результатов: Результаты вычислений суммируются в переменных `s` и `c`. Эта часть кода также распараллелена, так как каждый поток независимо суммирует свои значения `s` и `c`.

Результаты обработки: размер окна для всех изображений 5x5 пикселей.

Изображения 650x427

<image src="image/2.png" alt="Исходное изображение"  width="400"/> <image src="image/2-1.png" alt="После обработки"  width="400"/>

Изображения 1280x720

<image src="image/0.png" alt="Исходное изображение"  width="400"/> <image src="image/0-1.png" alt="После обработки"  width="400"/>

Изображения 1920x1280

<image src="image/1.png" alt="Исходное изображение"  width="400"/> <image src="image/1-1.png" alt="После обработки изображение"  width="400"/>

|Разрешение изображения|640x427|1280x720|1920x1280|
| :- | :- | :- | :- |
|CPU\_Time|54\.24971 s.|172\.98475 s.|356\.94134 s.|
|GPU\_Time|0\.09036 s.|0\.9068 s.|0\.39631 s.|
|Ускорение|600\.40|648\.06|900\.65|

s. – seconds

# Заключение

Выводы: перебрав все возможные способы реализации Pycuda является рабочим вариантом по крайней мере пока что для google colab,
библиотека cv2, работает намного быстрее, но так как это готовое решение я не рассматривал её за реализацию проекта.
Так же я понял что есть возможность реализации распараллеливанием разными способами.

